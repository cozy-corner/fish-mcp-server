# ADR-009: Base64画像のLRUキャッシュ戦略

## 状況

Base64画像サポートの実装において、以下の課題に対処する必要がある：

1. **パフォーマンス**: 画像のBase64変換は計算コストが高い（画像取得＋エンコード）
2. **メモリ使用量**: Base64データは元画像の約1.33倍のサイズ
3. **レート制限**: iNaturalist APIのレート制限への配慮
4. **MCPサーバーの特性**: 長時間稼働し、繰り返し同じ魚が検索される可能性

### 検討したキャッシュ戦略

1. **インメモリキャッシュ（LRU）**
2. **SQLiteキャッシュ（永続化）**
3. **ファイルシステムキャッシュ**
4. **ハイブリッドキャッシュ（メモリ＋ディスク）**

## 決定

**LRU（Least Recently Used）インメモリキャッシュを採用する。**

```typescript
class ImageLRUCache {
  private capacity: number = 50;        // 最大50画像
  private maxSizeMB: number = 100;      // 最大100MB
  private ttlMs: number = 3600000;      // 1時間
  private cache: Map<string, CacheEntry>;
}
```

## 理由

### 1. アクセスパターンとの適合性

魚検索の典型的な利用パターン：
- 人気のある魚（マグロ、サケ、タイ等）は頻繁に検索される
- 子供向けツールとして、同じ魚を繰り返し見る可能性が高い
- LRUは「よく使われるデータを保持」する特性がマッチ

### 2. 実装のシンプルさ

```typescript
// LRUの基本動作
get(key): 
  1. キャッシュにあれば最新位置に移動して返す
  2. なければnull

set(key, value):
  1. 容量/サイズ超過時は最古のエントリを削除
  2. 新しいエントリを最新位置に追加
```

- Map構造を使った効率的な実装が可能
- 複雑な永続化層が不要
- デバッグとテストが容易

### 3. パフォーマンス特性

| 操作 | 時間計算量 | 実時間 |
|------|------------|--------|
| 取得 | O(1) | < 1ms |
| 追加 | O(1) | < 1ms |
| 削除 | O(1) | < 1ms |

SQLiteやファイルシステムと比較して桁違いに高速。

### 4. メモリ使用量の制御

```typescript
// 画像サイズの想定
平均画像サイズ: 300KB
Base64変換後: 400KB
50画像の場合: 20MB（十分に現実的）

// サイズベース制限により100MBを超えない
```

### 5. MCPサーバーのライフサイクルとの整合性

- サーバー起動中のみキャッシュが必要
- 再起動時のキャッシュクリアは問題ない（コールドスタート）
- 永続化の複雑性を回避

## 代替案の分析

### SQLiteキャッシュの問題点

```sql
CREATE TABLE image_cache (
  url TEXT PRIMARY KEY,
  base64_data TEXT,  -- 大きなBLOBデータ
  ...
);
```

- ❌ I/O負荷が高い
- ❌ fish.dbのサイズが肥大化
- ❌ トランザクション管理の複雑性
- ❌ Base64の大きなテキストデータはSQLiteに不適

### ファイルシステムキャッシュの問題点

- ❌ ファイルI/Oのオーバーヘッド
- ❌ ディレクトリ管理の複雑性
- ❌ 権限やパスの問題
- ❌ クリーンアップ処理が必要

### ハイブリッドキャッシュの問題点

- ❌ 実装が複雑
- ❌ 2層管理のオーバーヘッド
- ❌ MVPには過剰な最適化

## 実装詳細

### キャッシュエントリ構造

```typescript
interface CacheEntry {
  base64: string;      // Base64エンコードされた画像
  mimeType: string;    // 画像のMIMEタイプ
  sizeBytes: number;   // メモリ使用量追跡用
  timestamp: number;   // TTL管理用
}
```

### エビクション戦略

1. **TTL期限切れ**: 1時間経過したエントリは取得時に削除
2. **容量超過**: 50画像を超えたら最も古いものを削除
3. **サイズ超過**: 100MBを超えたら古いものから削除

## 結果

### メリット

1. ✅ 高速な画像取得（キャッシュヒット時 < 1ms）
2. ✅ API呼び出し削減によるレート制限回避
3. ✅ シンプルで保守しやすい実装
4. ✅ メモリ使用量の予測可能性

### デメリット

1. ❌ サーバー再起動でキャッシュ消失
2. ❌ 分散環境では共有不可

### 監視指標

```typescript
// キャッシュ効果の測定
- ヒット率
- 平均応答時間
- メモリ使用量
- エビクション頻度
```

## 今後の考慮事項

1. **Phase 1完了後の評価**: 実使用でのキャッシュヒット率を測定
2. **永続化の再検討**: ヒット率が高ければ永続化層の追加を検討
3. **プリフェッチ**: 人気の魚の画像を事前取得
4. **圧縮**: Base64前の画像圧縮によるメモリ効率化

---

*この決定により、シンプルで効果的なキャッシュ戦略を実現し、ユーザー体験を大幅に向上させる。*