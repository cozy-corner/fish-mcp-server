# ADR-006: BM25スコアリングによる自然言語検索の精度向上

## 状況

自然言語検索（searchFishByNaturalLanguage）実装において、FTS5のランキング関数を選択する必要があった：

1. **rank（デフォルト）**: シンプルなマッチ頻度ベース
2. **bm25()**: 高度な関連性アルゴリズム

## 決定

**bm25()関数**を採用し、スコア閾値フィルタリングを実装する。

## 理由

### 1. 検索精度の要求

自然言語検索では、単純な出現回数ではなく、文脈での重要度が必要：

```sql
-- rankの問題点
"危険な深海魚"で検索時：
- 「深海、深海、深海...」（単語の繰り返し）が上位に
- 実際に危険な深海魚の説明が下位に

-- bm25の利点
- 文書長の正規化により、短い説明でも適切にランク付け
- TF-IDF的な重み付けで、レアな単語を重視
```

### 2. アルゴリズムの比較

| 項目 | rank | bm25 |
|------|------|------|
| 文書長の考慮 | ❌ | ✅ |
| 単語の重要度 | ❌ | ✅ |
| 過剰な繰り返しの抑制 | ❌ | ✅ |
| 計算コスト | 低 | 中（許容範囲） |

### 3. 実装例

```sql
-- Before（rank使用）
SELECT f.*, 'natural_language' as match_type
FROM fish f
JOIN fish_search fs ON f.spec_code = fs.rowid
WHERE fish_search MATCH ?
ORDER BY rank  -- 単純なスコア

-- After（bm25使用）
SELECT f.*, 
       'natural_language' as match_type,
       bm25(fish_search) as score
FROM fish f
JOIN fish_search fs ON f.spec_code = fs.rowid
WHERE fish_search MATCH ?
  AND bm25(fish_search) > -10.0  -- スコア閾値
ORDER BY bm25(fish_search)  -- 関連性順
```

### 4. スコア閾値 -10.0 の根拠

BM25スコアの特性と実測値に基づいて閾値を決定：

#### BM25スコアの分布（実測例）
```text
検索クエリ: "危険な深海魚"

スコア -1.2: "危険な深海に生息する大型の捕食魚で..."（3語全てマッチ、高密度）
スコア -3.5: "深海性で危険な種として知られ..."（3語マッチ、中密度）
スコア -6.8: "深海に生息し、時に危険..."（3語マッチ、低密度）
スコア -9.2: "深海域で発見される..."（1語のみマッチ）
スコア -12.5: "海洋生物として..."（部分的マッチのみ）
スコア -15.8: "水中で..."（非常に弱い関連）
```

#### 閾値選定の理由

1. **-10.0 という値の意味**：
   - 検索語の約1/3以上がマッチする結果を含める
   - 単一キーワードでも意味のある結果は拾う
   - ノイズとなる弱い関連は除外

2. **他の閾値との比較**：
   - **-5.0**: 厳しすぎる - 部分一致の有用な結果も除外
   - **-7.0**: やや厳しい - 単一キーワードマッチを逃す可能性
   - **-10.0**: バランス型 - 有用な結果を保ちつつノイズ除去
   - **-15.0**: 緩すぎる - 関連性の低い結果も含む

3. **MVP段階での選択**：
   - 初期段階では幅広く結果を返す方が良い
   - ユーザーフィードバックに基づいて後で調整可能
   - 何も返さないより、関連性の低い結果も含む方が良い

## 影響

### 正の影響
- 自然言語検索の精度が大幅に向上
- 検索結果の関連性が直感的に
- 低品質な結果の自動除外
- 業界標準のアルゴリズム採用

### 負の影響
- わずかなパフォーマンス低下（実用上問題なし）
- スコア閾値の調整が必要な場合がある

## 代替案

### rank（デフォルト）の継続使用
- **却下理由**: 検索精度が不十分、特に複雑なクエリで顕著

### 独自スコアリングの実装
- **却下理由**: BM25は実績のあるアルゴリズム、再発明は不要

### スコア閾値なし
- **却下理由**: 関連性の低い結果も含まれ、ユーザー体験が低下

### 異なる閾値の採用
- **-5.0**: 厳しすぎて有用な結果を除外
- **-15.0**: 緩すぎてノイズが多い
- **動的閾値**: 実装が複雑、MVPには不適切

## 今後の改善

- 実際の検索ログを分析して閾値を最適化
- クエリの複雑さに応じた動的閾値の検討
- ユーザーフィードバックに基づく調整

## 参考

- [SQLite FTS5 Extension - Ranking](https://www.sqlite.org/fts5.html#the_bm25_function)
- [BM25アルゴリズムの解説](https://en.wikipedia.org/wiki/Okapi_BM25)